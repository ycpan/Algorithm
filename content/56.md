# 合并区间
## 问题
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。



示例 1：
```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```
示例 2：
```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```
## 解答
要合并区间，我们可以按照区间的起始位置对区间进行排序，然后遍历排序后的区间，比较当前区间的起始位置与上一个区间的结束位置的关系。
以下是算法的步骤：
1. 如果当前区间的起始位置小于或等于上一个区间的结束位置，说明这两个区间有重叠，我们可以将上一个区间的结束位置更新为两个区间结束位置的最大值。
2. 如果当前区间的起始位置大于上一个区间的结束位置，说明这两个区间不重叠，我们将上一个区间添加到结果数组中，并更新上一个区间为当前区间。
在遍历结束后，别忘了将最后一个区间添加到结果数组中。
以下是这个算法的 Python 实现：
```python
def merge(intervals):
    # 按照区间的起始位置对区间进行排序
    intervals.sort(key=lambda x: x[0])

    # 初始化结果数组和上一个区间
    merged = []
    prev = intervals[0]

    # 遍历排序后的区间
    for curr in intervals[1:]:
        if curr[0] <= prev[1]:  # 如果当前区间与上一个区间有重叠
            prev[1] = max(prev[1], curr[1])  # 更新上一个区间的结束位置
        else:
            merged.append(prev)  # 如果没有重叠，将上一个区间添加到结果数组
            prev = curr  # 更新上一个区间为当前区间

    # 将最后一个区间添加到结果数组
    merged.append(prev)

    return merged
# 示例
intervals = [[1,3],[2,6],[8,10],[15,18]]
print(merge(intervals))  # 输出: [[1,6],[8,10],[15,18]]
intervals = [[1,4],[4,5]]
print(merge(intervals))  # 输出: [[1,5]]
```
这个算法的时间复杂度是 O(n log n)，因为排序操作需要 O(n log n) 的时间复杂度，而遍历区间并合并的操作是 O(n)。空间复杂度是 O(n)，因为我们需要一个额外的数组来存储合并后的区间。

