# 滑动窗口最大值
## 问题
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

示例 1：
```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```
示例 2：
```
输入：nums = [1], k = 1
输出：[1]
```
## 解法
要解决这个问题，我们可以使用一个双端队列（deque）来维护滑动窗口中的最大值。算法的大致思路如下：
1. 初始化一个双端队列，用于存储可能成为滑动窗口最大值的元素下标。
2. 遍历数组 `nums`，对于每个元素，先检查队列首部的元素是否已经不在滑动窗口中了（即下标小于当前元素下标减去 `k`），如果是，则将其从队列首部移除。
3. 然后将队列中小于当前元素的值全部从队列尾部移除，保证队列是单调递减的。
4. 将当前元素的下标加入队列尾部。
5. 当遍历的元素下标大于或等于 `k - 1` 时，将队列首部的元素（即当前滑动窗口的最大值）加入结果数组。
以下是这个算法的 Python 实现：
```python
from collections import deque
def maxSlidingWindow(nums, k):
    if not nums:
        return []

    # 双端队列，存储可能成为滑动窗口最大值的元素下标
    window = deque()
    # 结果数组
    result = []

    for i, num in enumerate(nums):
        # 检查队列首部的元素是否已经不在滑动窗口中了
        if window and window[0] < i - k + 1:
            window.popleft()
        # 将队列中小于当前元素的值全部从队列尾部移除
        while window and nums[window[-1]] < num:
            window.pop()
        # 将当前元素的下标加入队列尾部
        window.append(i)
        # 当遍历的元素下标大于或等于 k - 1 时，将队列首部的元素加入结果数组
        if i >= k - 1:
            result.append(nums[window[0]])

    return result
# 示例
nums = [1,3,-1,-3,5,3,6,7]
k = 3
print(maxSlidingWindow(nums, k))  # 输出: [3,3,5,5,6,7]
```
这个算法的时间复杂度是 O(n)，因为每个元素最多只会被加入和移除队列一次。空间复杂度是 O(k)，因为队列中最多只会有 `k` 个元素。

