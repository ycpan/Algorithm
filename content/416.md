# 分割等和子集
## 问题
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。



示例 1：
```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```
示例 2：
```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```
## 解答
这个问题可以通过动态规划来解决，它本质上是一个背包问题。我们需要判断是否存在一个子集，其元素和等于整个数组元素和的一半。
算法步骤如下：
1. 计算数组 `nums` 的总和 `total_sum`，如果总和是奇数，则不能分割成两个和相等的子集。
2. 初始化一个布尔类型的二维数组 `dp`，其中 `dp[i][j]` 表示从数组的前 `i` 个数字中选取一些数字，是否能凑出和为 `j`。初始时，`dp[0][0]` 为 `true`，因为总是可以凑出和为 0。
3. 遍历数组 `nums` 和所有可能的和，更新 `dp` 数组：
   - 如果当前数字 `nums[i-1]` 小于等于当前和 `j`，那么 `dp[i][j]` 可以从 `dp[i-1][j]` 或 `dp[i-1][j-nums[i-1]]` 转移而来。
   - 如果不选取当前数字，则 `dp[i][j] = dp[i-1][j]`；
   - 如果选取当前数字，则 `dp[i][j] = dp[i-1][j-nums[i-1]]`。
4. 最后，`dp[len(nums)][total_sum // 2]` 就是我们要找的答案，它表示是否能从数组中选取一些数字，使其和为 `total_sum // 2`。
现在，我们可以用 Python 代码来实现这个算法。
```
def canPartition(nums):
    # 计算数组总和
    total_sum = sum(nums)
    # 如果总和是奇数，则不能分割成两个和相等的子集
    if total_sum % 2 != 0:
        return False
    # 目标和
    target = total_sum // 2
    n = len(nums)
    # 初始化dp数组
    dp = [[False] * (target + 1) for _ in range(n + 1)]
    # 总和为0的情况总是可以凑出
    dp[0][0] = True
    # 遍历数组nums和所有可能的和
    for i in range(1, n + 1):
        for j in range(target + 1):
            if nums[i - 1] <= j:
                # 不选取当前数字或选取当前数字
                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]
            else:
                # 只能不选取当前数字
                dp[i][j] = dp[i - 1][j]
    # 返回是否能从数组中选取一些数字，使其和为target
    return dp[n][target]
# 测试示例
print(canPartition([1, 5, 11, 5]))  # 输出应该是 True
print(canPartition([1, 2, 3, 5]))   # 输出应该是 False
True
False
```
正如预期的那样，当输入为 `nums = [1, 5, 11, 5]` 时，输出是 `True`，因为数组可以分割成 `[1, 5, 5]` 和 `[11]`；当输入为 `nums = [1, 2, 3, 5]` 时，输出是 `False`，因为数组不能分割成两个元素和相等的子集。
这个算法有效地解决了给定的问题，通过动态规划判断了是否可以将数组分割成两个子集，使得两个子集的元素和相等。


