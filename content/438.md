# 找到子符串中所有字母的异位词
## 问题
给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。



示例 1:
```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```
 示例 2:
```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

## 解答
要解决这个问题，我们可以使用滑动窗口的方法。算法的基本思想是维护一个窗口，该窗口内的字符频率与字符串 `p` 的字符频率相同。我们遍历字符串 `s`，将字符加入窗口，并检查窗口中字符的频率是否与 `p` 的字符频率相同。如果相同，我们就记录下窗口的起始索引。
以下是算法的步骤：
1. 初始化一个字典来存储字符串 `p` 中每个字符的频率。
2. 初始化两个指针，一个表示窗口的左边界（left），一个表示窗口的右边界（right），以及一个列表来记录符合条件的子串的起始索引。
3. 在每一轮中，将右边界指向的字符加入窗口，并更新窗口中字符的频率。
4. 如果窗口中字符的频率与 `p` 的字符频率相同，则将窗口的左边界索引加入列表。
5. 移动右边界，继续检查下一个字符。
6. 当右边界到达字符串 `s` 的末尾时，停止遍历。
现在，我将用Python代码来实现这个算法。
```
def find_anagrams_corrected(s, p):
    # 初始化 p 的字符频率字典
    p_freq = Counter(p)
    # 初始化左右边界和结果列表
    left, right = 0, 0
    result = []
    # 遍历字符串 s
    while right < len(s):
        # 如果右边界指向的字符在 p 中
        if s[right] in p_freq:
            # 更新窗口中字符的频率
            p_freq[s[right]] -= 1
            # 如果窗口中字符的频率与 p 的字符频率相同
            while all(value <= 0 for value in p_freq.values()):
                # 如果窗口大小等于 p 的长度
                if right - left + 1 == len(p):
                    # 将窗口的左边界索引加入列表
                    result.append(left)
                # 移动左边界，并更新窗口中字符的频率
                if s[left] in p_freq:
                    p_freq[s[left]] += 1
                left += 1
        else:
            # 如果右边界指向的字符不在 p 中，重置窗口和字符频率
            p_freq = Counter(p)
            left = right + 1
        # 移动右边界
        right += 1
    return result
# 重新找到所有异位词的子串的起始索引
find_anagrams_corrected(s1, p1), find_anagrams_corrected(s2, p2)
([0, 6], [0, 1, 2])
```
使用给定的示例字符串：
- 对于字符串 "cbaebabacd" 和 "abc"，算法找到的异位词的子串的起始索引为 [0, 6]，这与预期结果相符。
- 对于字符串 "abab" 和 "ab"，算法找到的异位词的子串的起始索引为 [0, 1, 2]，这也与预期结果相符。

