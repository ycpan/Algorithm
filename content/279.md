# 完全平方数
## 问题
给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。



示例 1：
```
输入：n = 12
输出：3
解释：12 = 4 + 4 + 4
```
示例 2：
```
输入：n = 13
输出：2
解释：13 = 4 + 9

提示：

1 <= n <= 104
```
## 解答
这个问题是典型的动态规划问题，可以通过“完全背包问题”的思路来解决。我们需要找到和为 n 的完全平方数的最少数量。
动态规划的核心思想是，对于每一个数 n，我们记录下达到这个数所需的最少完全平方数的数量。对于每个完全平方数 x（x^2），我们更新数组 dp[i] 的值，其中 dp[i] 表示和为 i 的完全平方数的最少数量。
算法步骤如下：
1. 初始化一个数组 dp，其中 dp[0] = 0，因为和为 0 的完全平方数的最少数量是 0（即不需要任何数）。
2. 对于每个数 i（从 1 到 n），初始化 dp[i] 为一个很大的数，表示初始时和为 i 的完全平方数的最少数量是未知的。
3. 对于每个完全平方数 x（x^2），更新数组 dp 的值：
   - 对于每个 i（从 x^2 到 n），更新 dp[i] 为 min(dp[i], dp[i - x^2] + 1)。
最后，dp[n] 就是和为 n 的完全平方数的最少数量。
现在，我们可以用 Python 代码来实现这个算法。
```
def numSquares(n):
    # 初始化动态规划数组
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    # 计算完全平方数
    i = 1
    while i * i <= n:
        square = i * i
        # 更新dp数组
        for j in range(square, n + 1):
            dp[j] = min(dp[j], dp[j - square] + 1)
        i += 1
    return dp[n]
# 测试示例
print(numSquares(12))  # 输出应该是 3
print(numSquares(13))  # 输出应该是 2
3
2
```
正如预期的那样，当输入为 12 时，输出是 3，因为 12 可以表示为 4 + 4 + 4 的和；当输入为 13 时，输出是 2，因为 13 可以表示为 4 + 9 的和。
这个算法有效地解决了给定的问题，通过动态规划找到了和为 n 的完全平方数的最少数量。

