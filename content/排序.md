## 快速排序
```python
def quick_sort(li):
    quick_sort1(li, 0, len(li) - 1)
    return li

def quick_sort1(li, start, end):
    if start < end:
        pivot = partion(li, start, end)
        quick_sort1(li, start, pivot - 1)
        quick_sort1(li, pivot + 1, end)

def partion(li, low, high):
    pivot = li[low]
    while low < high:
        while low < high and li[high] >= pivot:
            high -= 1
        li[low] = li[high]
        while low < high and li[low] <= pivot:
            low += 1
        li[high] = li[low]
    li[low] = pivot
    return low

li = [3, 8, 2, 5, 1]
sorted_li = quick_sort(li)
print(sorted_li)
```
### 优化1
优化元素占用，直接在`li`上改
```python
def quick_sort(li):
    def partion(start,end):
        pivot = li[start]
        while(start < end):
            while start < end and li[end] >= pivot:
                end -= 1
            li[start]=li[end]
            while start < end and li[start] <= pivot:
                start += 1
            li[end] = li[start]
        li[start] = pivot
        return start
    def sub_quick_sort(start,end):
        if start < end:
            pivot_index = partion(start,end)
            sub_quick_sort(start,pivot_index - 1)
            sub_quick_sort(pivot_index + 1,end)
    sub_quick_sort(0,len(li)-1)
    return li
if __name__ == '__main__':
    li = [3,2,8,9,1]
    new_li = quick_sort(li)
    print(li)
```
### 优化2(重要)
优化交换次数,这里定义一个交换
```python
def solve(li):
    def swap(i,j):
        li[i],li[j] = li[j],li[i]
    def quick_sort(start,end):
        original_start = start
        pivot = li[original_start]
        #import ipdb
        #ipdb.set_trace()
        while start < end:
            while start < end and li[end] >= pivot:
                end -= 1
            while start < end and li[start] <= pivot:
                start += 1
            if start < end:
                swap(start,end)
        #li[start] = pivot
        swap(original_start,start)#注意，这个地方不能用赋值(li[start] = pivot)，智能用交换，否则最新位置start将被覆盖。
        #if start == k:
        #    return li[start]
        #if start <
        return start
    def my_quick_sort(start,end):
        if start < end:
            pivot_index = quick_sort(start,end)
            my_quick_sort(start,pivot_index - 1)
            my_quick_sort(pivot_index + 1,end)
    my_quick_sort(0,len(li)-1)
    return li
li = [3,2,8,9,1]
new_li = solve(li)
print(new_li)

```
### 拓展
找第k个最大的数，详见[数组中的第K个最大元素](./215.md),这里也写了一下。
```python
def solve(li,k):
    def swap(i,j):
        li[i],li[j] = li[j],li[i]
    def quick_sort(start,end):
        original_start = start
        pivot = li[original_start]
        while start < end:
            while start < end and li[end] <= pivot: # 第k个最大的，要从大到小进行排序
                end -= 1
            while start < end and li[start] >= pivot:# 第k个最大的，要从大到小进行排序
                start += 1
            if start < end:
                swap(start,end)
        #li[start] = pivot # 上文用到了交换，而不是一个接着一个的赋值，所以这里也带用交换，否则最新start位置上的元素会被覆盖掉。
        swap(original_start,start)
        #if start == k:
        #    return li[start]
        #if start <

        return start
    def my_quick_sort(start,end):
        res = None
        if start < end:
            pivot_index = quick_sort(start,end)
            #import ipdb
            #ipdb.set_trace()
            if pivot_index == k-1:
                return li[pivot_index]
            if pivot_index > k - 1:
                res = my_quick_sort(start,pivot_index - 1)
            if pivot_index < k - 1:
                res = my_quick_sort(pivot_index + 1,end)
        return res 
    res = my_quick_sort(0,len(li)-1)
    #return li
    return res
li = [3,2,8,9,1]
new_li = solve(li,3)
print(new_li)

```
### 优化3
为了使快速排序算法更加高效和简练，我们可以进行以下优化：
1. **选择合适的基准（Pivot）**：避免选择列表的第一个元素作为基准，因为这可能会导致算法在最坏情况下的性能下降。我们可以选择列表的中间元素或随机元素作为基准。
2. **使用插入排序**：对于小数组，插入排序比快速排序更有效。因此，我们可以设置一个阈值，当子数组的长度小于这个阈值时，使用插入排序来排序。
3. **避免不必要的交换**：在分区过程中，我们可以避免不必要的交换，而是在最后一步将基准元素放到正确的位置。
下面是优化后的代码：
```python
def quick_sort_optimized(li):
    def quick_sort1(li, start, end):
        if end - start < 16:
            insertion_sort(li, start, end)
            return
        if start < end:
            pivot = partion(li, start, end)
            quick_sort1(li, start, pivot - 1)
            quick_sort1(li, pivot + 1, end)
    def partion(li, low, high):
        mid = (low + high) // 2
        li[low], li[mid] = li[mid], li[low]  # Swap the middle element with the low element
        pivot = li[low]
        while low < high:
            while low < high and li[high] >= pivot:
                high -= 1
            li[low] = li[high]
            while low < high and li[low] <= pivot:
                low += 1
            li[high] = li[low]
        li[low] = pivot
        return low
    def insertion_sort(li, start, end):
        for i in range(start + 1, end + 1):
            key = li[i]
            j = i - 1
            while j >= start and key < li[j]:
                li[j + 1] = li[j]
                j -= 1
            li[j + 1] = key
    quick_sort1(li, 0, len(li) - 1)
    return li
li = [3, 8, 2, 5, 1]
sorted_li_optimized = quick_sort_optimized(li)
sorted_li_optimized
[1, 2, 3, 5, 8]
```
优化后的快速排序算法已经成功运行，排序结果仍然是：[1, 2, 3, 5, 8]。
在这个优化版本中，我做了以下改进：
1. 当子数组的长度小于16时，使用插入排序来排序，因为对于小数组，插入排序比快速排序更高效。
2. 选择列表的中间元素作为基准，以减少在最坏情况下的性能下降。
3. 避免在分区过程中的不必要交换，而是在最后一步将基准元素放到正确的位置。

