## 快速排序
```python
def quick_sort(li):
    quick_sort1(li, 0, len(li) - 1)
    return li

def quick_sort1(li, start, end):
    if start < end:
        pivot = partion(li, start, end)
        quick_sort1(li, start, pivot - 1)
        quick_sort1(li, pivot + 1, end)

def partion(li, low, high):
    pivot = li[low]
    while low < high:
        while low < high and li[high] >= pivot:
            high -= 1
        li[low] = li[high]
        while low < high and li[low] <= pivot:
            low += 1
        li[high] = li[low]
    li[low] = pivot
    return low

li = [3, 8, 2, 5, 1]
sorted_li = quick_sort(li)
print(sorted_li)
```
### 快速排序的优化
为了使快速排序算法更加高效和简练，我们可以进行以下优化：
1. **选择合适的基准（Pivot）**：避免选择列表的第一个元素作为基准，因为这可能会导致算法在最坏情况下的性能下降。我们可以选择列表的中间元素或随机元素作为基准。
2. **使用插入排序**：对于小数组，插入排序比快速排序更有效。因此，我们可以设置一个阈值，当子数组的长度小于这个阈值时，使用插入排序来排序。
3. **避免不必要的交换**：在分区过程中，我们可以避免不必要的交换，而是在最后一步将基准元素放到正确的位置。
下面是优化后的代码：
```python
def quick_sort_optimized(li):
    def quick_sort1(li, start, end):
        if end - start < 16:
            insertion_sort(li, start, end)
            return
        if start < end:
            pivot = partion(li, start, end)
            quick_sort1(li, start, pivot - 1)
            quick_sort1(li, pivot + 1, end)
    def partion(li, low, high):
        mid = (low + high) // 2
        li[low], li[mid] = li[mid], li[low]  # Swap the middle element with the low element
        pivot = li[low]
        while low < high:
            while low < high and li[high] >= pivot:
                high -= 1
            li[low] = li[high]
            while low < high and li[low] <= pivot:
                low += 1
            li[high] = li[low]
        li[low] = pivot
        return low
    def insertion_sort(li, start, end):
        for i in range(start + 1, end + 1):
            key = li[i]
            j = i - 1
            while j >= start and key < li[j]:
                li[j + 1] = li[j]
                j -= 1
            li[j + 1] = key
    quick_sort1(li, 0, len(li) - 1)
    return li
li = [3, 8, 2, 5, 1]
sorted_li_optimized = quick_sort_optimized(li)
sorted_li_optimized
[1, 2, 3, 5, 8]
```
优化后的快速排序算法已经成功运行，排序结果仍然是：[1, 2, 3, 5, 8]。
在这个优化版本中，我做了以下改进：
1. 当子数组的长度小于16时，使用插入排序来排序，因为对于小数组，插入排序比快速排序更高效。
2. 选择列表的中间元素作为基准，以减少在最坏情况下的性能下降。
3. 避免在分区过程中的不必要交换，而是在最后一步将基准元素放到正确的位置。

