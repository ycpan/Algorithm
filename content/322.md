# 零钱兑换
## 问题
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。



示例 1：
```
输入：coins = [1, 2, 5], amount = 11
输出：3
解释：11 = 5 + 5 + 1
```
示例 2：
```
输入：coins = [2], amount = 3
输出：-1
```
示例 3：
```
输入：coins = [1], amount = 0
输出：0
```
## 解答
这个问题是典型的动态规划问题，可以通过“完全背包问题”的思路来解决。我们需要找到凑成总金额所需的最少硬币个数。
动态规划的核心思想是，对于每一个金额 amount，我们记录下达到这个金额所需的最少硬币个数。对于每种硬币 coin，我们更新数组 dp 的值，其中 dp[i] 表示凑成金额 i 所需的最少硬币个数。
算法步骤如下：
1. 初始化一个数组 dp，其中 dp[0] = 0，因为凑成金额 0 所需的最少硬币个数是 0（即不需要任何硬币）。
2. 对于每个金额 i（从 1 到 amount），初始化 dp[i] 为一个很大的数，表示初始时凑成金额 i 所需的最少硬币个数是未知的。
3. 对于每种硬币 coin，更新数组 dp 的值：
   - 对于每个 i（从 coin 到 amount），更新 dp[i] 为 min(dp[i], dp[i - coin] + 1)。
最后，dp[amount] 就是凑成总金额所需的最少硬币个数。如果 dp[amount] 仍然是初始时设置的一个很大的数，那么返回 -1，表示无法凑成总金额。
现在，我们可以用 Python 代码来实现这个算法。
```
def coinChange(coins, amount):
    # 初始化动态规划数组
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    # 更新dp数组
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)
    # 如果dp[amount]仍然是初始时设置的一个很大的数，返回-1
    return dp[amount] if dp[amount] != float('inf') else -1
# 测试示例
print(coinChange([1, 2, 5], 11))  # 输出应该是 3
print(coinChange([2], 3))         # 输出应该是 -1
print(coinChange([1], 0))         # 输出应该是 0
3
-1
0
```
正如预期的那样，当输入为 `coins = [1, 2, 5], amount = 11` 时，输出是 3，因为 11 可以表示为 5 + 5 + 1 的和；当输入为 `coins = [2], amount = 3` 时，输出是 -1，因为无法用硬币 2 凑成金额 3；当输入为 `coins = [1], amount = 0` 时，输出是 0，因为不需要任何硬币就可以凑成金额 0。
这个算法有效地解决了给定的问题，通过动态规划找到了凑成总金额所需的最少硬币个数。

