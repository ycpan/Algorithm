# 前K个高频元素
## 问题
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。



示例 1:
```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```
示例 2:
```
输入: nums = [1], k = 1
输出: [1]
```
## 思考
本题有3种类解法:
1. 使用小堆解决，里面存最大的k个数，空间复杂度为o（k);因为一次插入小堆的时间为o(log),大约要插入n次，所以，时间复杂度为nlogn;也可以用大堆解决，要不所有的数都存进去，所以空间复杂度为o(n)
2. 使用快排解决，时间复杂度为nlogn,快排没有使用额外的空间，只有几个变量，空间复杂度o(1)
3. 从数组num中随机选一个数字，如果比这个数字大，就放在一堆A中，如果小，就放在另一堆B中；如果堆A中的元素大于k个，从堆A中选k个；如果小于k个，则从堆B中选k-len(堆A)个数字.时间复杂度平均为n

## 解答(第一种）
这个问题是典型的“前K个高频元素”问题，可以使用哈希表（Python中的字典）来记录每个元素出现的频率，然后使用堆（Python中的`heapq`模块）来找出出现频率最高的前K个元素。
在Python中，你可以使用以下步骤来解决这个问题：
1. 使用字典统计每个元素出现的频率。
2. 利用`heapq`模块的`nlargest`函数，根据频率找出出现次数最多的前K个元素。
下面是相应的Python代码实现：
```python
import heapq
from collections import Counter
def topKFrequent(nums, k):
    # 统计每个数字出现的频率
    freq = Counter(nums)
    # 构建一个最小堆，大小为k
    return heapq.nlargest(k, freq.keys(), key=freq.get)
# 示例1
nums = [1,1,1,2,2,3]
k = 2
print(topKFrequent(nums, k))  # 输出: [1, 2]
# 示例2
nums = [1]
k = 1
print(topKFrequent(nums, k))  # 输出: [1]
```
这段代码首先利用`Counter`来统计每个元素出现的频率，然后使用`heapq.nlargest`来找出频率最高的前K个元素。函数`heapq.nlargest`会返回一个列表，列表中的元素是按照频率从高到低排列的。

这个代码的小根堆是用python自己的数据结构，如何手动构建小跟堆吗，请看下文。
### 手动构建最小堆
小根堆（Min Heap）是一种数据结构，它满足任何一个父节点的值都小于或等于其子节点的值。在编程中，我们通常使用数组来实现堆。下面是一个用Python实现的小根堆的简单例子，包括插入和删除最小元素的功能。
```python
class MinHeap:
    def __init__(self):
        self.heap = []
    def parent(self, i):
        return (i - 1) // 2
    def left_child(self, i):
        return 2 * i + 1
    def right_child(self, i):
        return 2 * i + 2
    def has_left_child(self, i):
        return self.left_child(i) < len(self.heap)
    def has_right_child(self, i):
        return self.right_child(i) < len(self.heap)
    def swap(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    def insert(self, key):
        self.heap.append(key)
        i = len(self.heap) - 1
        while i > 0 and self.heap[self.parent(i)] > self.heap[i]:
            self.swap(i, self.parent(i))
            i = self.parent(i)
    def extract_min(self):
        if len(self.heap) == 0:
            raise Exception("Heap is empty")
        min_val = self.heap[0]
        # Move the last item in the heap to the root and heapify
        self.heap[0] = self.heap[-1]
        self.heap.pop()
        i = 0
        while self.has_left_child(i):
            min_child_idx = self.left_child(i)
            if (self.has_right_child(i) and
                    self.heap[self.right_child(i)] < self.heap[self.left_child(i)]):
                min_child_idx = self.right_child(i)
            if self.heap[i] < self.heap[min_child_idx]:
                break
            self.swap(i, min_child_idx)
            i = min_child_idx
        return min_val
# 使用小根堆
min_heap = MinHeap()
min_heap.insert(3)
min_heap.insert(1)
min_heap.insert(4)
min_heap.insert(1)
min_heap.insert(5)
print("Extracted:", min_heap.extract_min())  # 应该输出 1
print("Extracted:", min_heap.extract_min())  # 应该输出 1
print("Extracted:", min_heap.extract_min())  # 应该输出 3
```
这个程序定义了一个`MinHeap`类，其中包含了插入（`insert`）和提取最小元素（`extract_min`）的方法。插入操作会将新元素添加到堆的末尾，然后不断与其父节点交换，直到满足小根堆的性质。提取最小元素操作会移除堆顶元素，并将堆的最后一个元素移动到堆顶，然后重新调整堆，以保持小根堆的性质。
## 解答(第二种）
```python
def quick_sort(nums, k):
    # 从nums数组中选择最大的k个数，并且不使用额外存储空间
    # 这个时间复杂度为nlogn,时间复杂度并不是最优的
    # 最优的是从数组num中随机选一个数字，如果比这个数字大，就放在一堆A中，如果小，就放在另一堆B中；如果堆A中的元素大于k个，从堆A中选k个；如果小于k个，则从堆B中选k-len(堆A)个数字.时间复杂度平均为n
    
    start = 0
    end = len(nums) - 1
    if k > len(nums):
        return 
    def quick_sort_1(start,end,nums):
        i = start
        j = end
        if i >= j:
            return
        flag = data[start]
        while i < j:
            while i<j and data[j] >= flag:
                j -= 1
            data[i] = data[j]
            while i < j and data[i] <= flag:
                i += 1
            data[j] = data[i]
        data[i] = flag
        quickSort(data,start,i - 1)
        quickSort(data,i + 1,end)
    quick_sort_1(start,end,nums)
    return nums[end-k:]
```
## python中的heapq
### heapq介绍
在Python中，`heapq`模块提供了一个堆队列算法的实现，也称为优先队列算法。这个模块提供了对堆操作的函数，包括插入元素、弹出最小元素、堆排序等。`heapq`模块实现的是最小堆，这意味着堆中的最小元素总是在索引0的位置。
以下是`heapq`模块的一些基本操作：
1. `heapq.heappush(heap, item)`：将`item`加入到`heap`中，保持堆的顺序。
2. `heapq.heappop(heap)`：从`heap`中弹出最小的元素，并返回它，同时保持堆的顺序。
3. `heapq.heapify(iterable)`：将`iterable`转换为一个堆，原地操作，时间复杂度为O(n)。
4. `heapq.heapreplace(heap, item)`：弹出并返回`heap`中的最小元素，并将`item`插入到堆中。
5. `heapq.merge(*iterables, key=None, reverse=False)`：将多个有序的`iterables`合并为一个有序的迭代器。
6. `heapq.nlargest(n, iterable, key=None)`：从`iterable`中返回最大的`n`个元素。
7. `heapq.nsmallest(n, iterable, key=None)`：从`iterable`中返回最小的`n`个元素。
下面是一个使用`heapq`模块的例子：
```python
import heapq
# 创建一个列表
nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
# 使用heapify将列表转换为堆
heapq.heapify(nums)
# 弹出最小元素
print("Min element:", heapq.heappop(nums))  # 输出: Min element: 0
# 插入新元素
heapq.heappush(nums, -1)
# 弹出最小元素
print("Min element:", heapq.heappop(nums))  # 输出: Min element: -1
# 使用nlargest和nsmallest获取最大和最小的n个元素
print("3 largest elements:", heapq.nlargest(3, nums))  # 输出: 3 largest elements: [8, 7, 6]
print("3 smallest elements:", heapq.nsmallest(3, nums))  # 输出: 3 smallest elements: [1, 2, 3]
```
`heapq`模块中的堆是一个列表，但是这个列表满足堆的性质：对于所有的`i`，都满足`heap[i] <= heap[2*i+1]`和`heap[i] <= heap[2*i+2]`。这意味着你可以通过索引来访问堆中的元素，但是不要直接修改这些元素，因为这可能会破坏堆的顺序。如果需要修改堆中的元素，应该使用`heapq.heapreplace`或者先删除后插入。

### heapq数据结构
`heapq` 是 Python 的一个标准库，它提供了堆队列算法的实现。堆是一种特殊的树形数据结构，每个节点都满足堆属性。在 Python 的 `heapq` 模块中，它实现了一个二叉堆，具体是一个最小堆。
在最小堆中，对于每个节点 `i`，都满足以下性质：
- `heap[i]` <= `heap[2 * i + 1]` （左子节点）
- `heap[i]` <= `heap[2 * i + 2]` （右子节点）
堆通常用于优先队列的实现，因为它可以在对数时间复杂度内找到并删除最小元素（在最小堆的情况下，或者最大元素在最大堆的情况下）。
`heapq` 模块提供了以下两种常用的函数来获取队列中的最小或最大元素：
- `heapq.heappop(heap)`：弹出并返回当前堆中的最小元素（在最小堆的情况下），堆结构会进行调整以维持堆属性。
- `heapq.heappush(heap, item)`：将新元素 `item` 添加到堆 `heap` 中，堆结构会进行调整以维持堆属性。
除此之外，`heapq` 模块还提供了 `heapq.nlargest(n, iterable)` 和 `heapq.nsmallest(n, iterable)` 函数，这两个函数分别用于找出 `iterable` 中最大的 `n` 个元素和最小的 `n` 个元素。
为什么会有 `heapq.nlargest` 和 `heapq.nsmallest` 呢？这是因为有时候我们不仅需要找出整个数据集中的最小或最大元素，还需要找出若干个最小或最大元素。如果数据量很大，手动排序后再取部分元素会非常低效。而 `heapq` 模块利用堆这种数据结构，可以在不进行完全排序的情况下，高效地找到若干个最小或最大元素。
`heapq.nlargest` 和 `heapq.nsmallest` 的内部实现通常会创建一个大小为 `n` 的堆，然后遍历数据集中的所有元素，将元素添加到堆中，并保持堆的大小不超过 `n`。这样，遍历结束后，堆中就保留了数据集中 `n` 个最大或最小的元素。由于堆的大小始终保持在 `n`，所以这些操作的时间复杂度是线性的，即 `O(n)`。

