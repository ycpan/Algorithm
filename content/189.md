# 转轮数组
## 问题
给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。



示例 1:
```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```
示例 2:
```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释:
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```
## 解答
要解决这个问题，我们可以使用一个额外的数组来存储旋转后的结果，也可以在不使用额外空间的情况下进行原地旋转。以下是原地旋转的步骤：
1. 首先，我们需要处理 `k` 可能大于数组长度的情况，因为每旋转数组长度个位置，数组就会回到原始状态。所以，我们可以对 `k` 取模数组长度，得到实际需要旋转的位置数。
2. 接下来，我们需要找到数组旋转的分割点，即将数组分为两部分，前半部分需要移动到数组后面，后半部分需要移动到数组前面。我们可以通过计算 `(len(nums) - k % len(nums))` 来找到这个分割点。
3. 然后，我们可以通过三次反转数组来达到旋转的效果：首先反转整个数组，然后反转数组的前半部分，最后反转数组的后半部分。
以下是这个算法的 Python 实现：
```python
def rotate(nums, k):
    n = len(nums)
    k %= n  # 处理 k 大于数组长度的情况

    def reverse(start, end):
        while start < end:
            nums[start], nums[end] = nums[end], nums[start]
            start += 1
            end -= 1

    # 反转整个数组
    reverse(0, n-1)
    # 反转数组的前半部分
    reverse(0, k-1)
    # 反转数组的后半部分
    reverse(k, n-1)
# 示例
nums = [1,2,3,4,5,6,7]
k = 3
rotate(nums, k)
print(nums)  # 输出: [5,6,7,1,2,3,4]
nums = [-1,-100,3,99]
k = 2
rotate(nums, k)
print(nums)  # 输出: [3,99,-1,-100]
```
这个算法的时间复杂度是 O(n)，因为每个元素都会被反转三次，总共大约 `3n` 次操作。空间复杂度是 O(1)，因为我们在原地操作数组，不需要额外的存储空间。

