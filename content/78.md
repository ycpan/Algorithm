# 子集
## 问题
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的
子集
（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。



示例 1：
```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```
示例 2：
```
输入：nums = [0]
输出：[[],[0]]


提示：

1 <= nums.length <= 10
-10 <= nums[i] <= 10
nums 中的所有元素 互不相同
```
## 解答
要解决这个问题，我们可以使用回溯算法。回溯算法是一种通过探索所有可能的候选解来找出所有的解的算法。对于子集问题，我们可以使用一种称为“选择与不选择”的方法，即对于数组中的每个元素，我们都可以选择将其包含在子集中或者不包含在子集中。
以下是使用Python实现的回溯算法来解决这个问题的代码示例：
```python
def subsets(nums):
    def backtrack(start, path):
        # 将当前路径添加到结果中
        output.append(path[:])
        # 从start开始遍历数组
        for i in range(start, len(nums)):
            # 选择当前数字，加入到路径中
            path.append(nums[i])
            # 递归调用，处理下一个数字
            backtrack(i + 1, path)
            # 回溯，撤销选择
            path.pop()

    output = []
    backtrack(0, [])
    return output
# 示例
nums = [1,2,3]
print(subsets(nums))
```
这段代码定义了一个内部函数 `backtrack`，它负责执行回溯操作。对于数组 `nums` 中的每个数字，我们有两个选择：要么将其包含在当前子集中，要么不包含。我们通过递归调用 `backtrack` 来处理这两种情况。每次递归调用后，我们都会通过撤销最后的选择来回到上一步的状态，这就是回溯的过程。
`subsets` 函数初始化一个空列表 `output` 来存储所有的子集，然后调用 `backtrack` 函数来生成这些子集。最后，函数返回这个列表作为结果。由于每个数字都有两种选择（选择或不选择），因此最终会有 `2^n` 个子集，其中 `n` 是数组 `nums` 的长度。

