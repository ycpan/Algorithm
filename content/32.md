# 最长有效括号
## 问题
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号
子串
的长度。



示例 1：
```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```
示例 2：
```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```
示例 3：
```
输入：s = ""
输出：0
```
## 解答
要解决这个问题，我们可以使用一个栈的数据结构。栈是一种后进先出（Last In First Out, LIFO）的数据结构，非常适合处理括号匹配的问题。我们可以遍历字符串，对于每个左括号，我们将其索引推入栈中；对于每个右括号，我们执行以下操作：
1. 如果栈为空，说明当前的右括号没有匹配的左括号，我们将其索引推入栈中。
2. 如果栈不为空，说明有匹配的左括号，我们弹出栈顶元素。此时，我们计算当前索引与栈顶元素索引的差值，这个差值就是以当前右括号为结尾的最长有效括号子串的长度。我们需要更新最大长度。
在遍历结束后，我们还需要处理栈中剩余的索引。这些索引对应于没有匹配的左括号。我们可以使用一个变量来记录最后一个没有匹配的左括号的索引，然后用当前索引减去这个变量，就可以得到最后一个有效括号子串的长度。
以下是具体的算法步骤：
1. 初始化一个栈，将-1推入栈中作为初始的基准索引。
2. 初始化一个变量，记录最大长度。
3. 遍历字符串，对于每个字符：
   - 如果是左括号，将其索引推入栈中。
   - 如果是右括号，首先判断栈是否为空：
     - 如果栈为空，将当前索引推入栈中。
     - 如果栈不为空，弹出栈顶元素，计算当前索引与栈顶元素索引的差值，更新最大长度。
4. 遍历结束后，如果栈中还有元素，说明还有没有匹配的左括号。计算最后一个有效括号子串的长度，更新最大长度。
5. 返回最大长度。
现在，我将使用Python编写这个算法的代码。
```python
def longest_valid_parentheses(s: str) -> int:
    stack = [-1]
    max_length = 0
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_length = max(max_length, i - stack[-1])
    if stack:
        max_length = max(max_length, len(s) - 1 - stack[-1])
    return max_length
# 测试示例
test_cases = ["(()", ")()())", ""]
results = [longest_valid_parentheses(tc) for tc in test_cases]
results
[2, 4, 0]
```
根据编写的算法，我们得到了以下结果：
- 对于字符串 "(()"，最长有效括号子串的长度为 2，即 "()".
- 对于字符串 ")()())"，最长有效括号子串的长度为 4，即 "()()".
- 对于空字符串，最长有效括号子串的长度为 0。
这些结果与示例中的预期输出相符。

