# 颜色分类
## 问题
给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。



示例 1：
```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```
示例 2：
```
输入：nums = [2,0,1]
输出：[0,1,2]
```
## 解答
要解决这个问题，我们可以使用荷兰国旗问题中的三指针方法。这个方法的基本思想是，设置三个指针，分别代表红色、白色和蓝色区域的边界。遍历数组时，根据当前元素的颜色，移动这些指针，从而将数组分为三个部分：红色部分、白色部分和蓝色部分。
具体步骤如下：
1. 设置三个指针，`low`、`mid` 和 `high`，初始时 `low` 和 `mid` 都在数组的起始位置，`high` 在数组的末尾。
2. `mid` 遍历数组，对于每个元素：
   - 如果元素是红色（0），则与 `low` 指针指向的元素交换，并将 `low` 和 `mid` 都向前移动一位。
   - 如果元素是白色（1），则 `mid` 向前移动一位。
   - 如果元素是蓝色（2），则与 `high` 指针指向的元素交换，并将 `high` 向前移动一位。注意，由于交换过来的元素还没有被处理，所以 `mid` 不移动。
3. 重复步骤 2，直到 `mid` 超过 `high`。
现在，我将使用 Python 来实现这个算法。
```python
def sort_colors(nums: list[int]) -> None:
    low, mid, high = 0, 0, len(nums) - 1
    while mid <= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:  # nums[mid] == 2
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1
# 测试示例
test_cases = [[2, 0, 2, 1, 1, 0], [2, 0, 1]]
for nums in test_cases:
    sort_colors(nums)
    print(nums)
[0, 0, 1, 1, 2, 2]
[0, 1, 2]
```
根据计算结果，我们得到以下答案：
- 对于数组 [2, 0, 2, 1, 1, 0]，排序后的数组是 [0, 0, 1, 1, 2, 2]。
- 对于数组 [2, 0, 1]，排序后的数组是 [0, 1, 2]。
这些结果与示例中的预期输出相符。



