# 背包问题（从盒子里取糖果）
## 问题

现有一排盒子，每个盒子里都放着数量不等的糖果。

现在从每个盒子里取糖果，要求不能连续从相邻的盒子里取
比如取了第一个盒子的糖果，第二个则盒子不能取，计算能获得最多的糖果数。
## 解答
1. 这个问题是一个经典的动态规划问题，可以通过动态规划算法来解决。我们可以这样思考：

2. 设有数组 candies 表示每个盒子里的糖果数，数组的长度为 `n`。
3. 创建新的数组`dp`，其中`dp[i]`表示从第`i`个盒子开始，能获得的最多糖果数。
对于`dp[i]`，有两种选择：
- 从第`i`个盒子取糖果，那么就不能从第`i+1`个盒子取，此时能获得的糖果数为`candies[i] + dp[i+2]`。
- 不从第`i`个盒子取糖果，此时能获得的糖果数为`dp[i+1]`。
4. 因此，`dp[i]`应该取这两种选择的较大值，即`dp[i] = max(candies[i] + dp[i+2], dp[i+1])`。
5. 最后，`dp[0]`就是从第一个盒子开始能获得的最多糖果数。
```python
def max_candies(candies):
    n = len(candies)
    if n == 0:
        return 0
    if n == 1:
        return candies[0]
    if n == 2:
        return max(candies)

    dp = [0] * n
    dp[0] = candies[0]
    dp[1] = max(candies[0], candies[1])

    for i in range(2, n):
        dp[i] = max(candies[i] + dp[i-2], dp[i-1])

    return dp[-1]

# 示例
candies = [4, 1, 2, 9, 3, 6]
max_candies(candies)
```

