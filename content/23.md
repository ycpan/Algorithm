# 合并K个升序链表
## 问题
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。



示例 1：
```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```
示例 2：
```
输入：lists = []
输出：[]
```
示例 3：
```
输入：lists = [[]]
输出：[]
```
## 解答
要合并多个已排序链表，可以使用优先队列（最小堆）来高效地进行合并。以下是使用Python实现的示例代码：
```python
# 定义单链表的节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
# 合并链表的函数
def mergeKLists(lists):
    import heapq
    
    # 创建一个虚拟头节点，方便操作
    dummy = ListNode()
    current = dummy
    
    # 创建一个最小堆，用于从所有链表的头节点中找出最小的节点
    heap = []
    for i, head in enumerate(lists):
        if head:
            # 将每个链表的头节点和其在链表数组中的索引组成元组，加入最小堆
            heapq.heappush(heap, (head.val, i))
    
    # 当最小堆不为空时，进行循环
    while heap:
        # 弹出最小堆的堆顶元素，即当前所有链表头节点中的最小值及其索引
        val, idx = heapq.heappop(heap)
        # 获取对应链表的头节点，并链接到结果链表中
        node = lists[idx]
        current.next = node
        current = current.next
        # 将链表的头节点向后移动一位
        lists[idx] = node.next
        # 如果链表的下一个节点不为空，则将其加入最小堆
        if node.next:
            heapq.heappush(heap, (node.next.val, idx))
    
    # 返回合并后的链表（去除虚拟头节点）
    return dummy.next
# 创建链表数组的函数，用于测试
def create_lists(lst):
    dummy = ListNode()
    current = dummy
    for l in lst:
        for val in l:
            current.next = ListNode(val)
            current = current.next
    return dummy.next
# 测试代码
if __name__ == "__main__":
    lists = [[1,4,5],[1,3,4],[2,6]]
    lists_nodes = [create_lists(lst) for lst in lists]
    result = mergeKLists(lists_nodes)
    while result:
        print(result.val, end=' ')
        result = result.next
```
此代码定义了一个`ListNode`类来表示链表节点，并定义了一个`mergeKLists`函数来合并链表。在`mergeKLists`函数中，我们使用Python的`heapq`模块来创建一个最小堆，并以此维护当前所有链表头节点中的最小值。每次从堆中取出最小值，并将其从原链表中移除，然后将其添加到结果链表中。如果原链表中有下一个节点，则将其加入最小堆中。重复此过程，直到所有链表都被遍历完毕。
测试代码部分创建了示例中的链表数组，并调用了`mergeKLists`函数，最后打印出合并后的链表。

