# 移动零
## 问题
给定一个数组`nums`，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

示例 1:
```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```
示例 2:
```
输入: nums = [0]
输出: [0]
```
## 解题
要解决这个问题，我们可以使用双指针技巧。算法的大致步骤如下：
1. 初始化两个指针，`left` 和 `right`，都指向数组的起始位置。
2. `left` 指针用于指向下一个非零元素应该放置的位置。
3. `right` 指针用于遍历数组，寻找非零元素。
4. 当 `right` 指针找到一个非零元素时，将 `nums[right]` 和 `nums[left]` 交换，然后将 `left` 指针向右移动一位。
5. 重复步骤 3-4，直到 `right` 指针遍历完整个数组。
6. 由于所有非零元素都已经被移动到了数组的前面，剩下的位置都应该填充为 0。
以下是这个算法的 Python 实现：
```python
def moveZeroes(nums):
    left = 0  # 下一个非零元素应该放置的位置
    
    # 遍历数组，寻找非零元素
    for right in range(len(nums)):
        if nums[right] != 0:
            # 交换非零元素到它应该放置的位置
            nums[left], nums[right] = nums[right], nums[left]
            left += 1  # 移动 left 指针
    
    # 由于所有非零元素都已经被移动到了数组的前面，剩下的位置都应该填充为 0
    # 但是在这个算法中，由于非零元素的相对顺序已经保持，所以不需要这一步
# 示例
nums = [0,1,0,3,12]
moveZeroes(nums)
print(nums)  # 输出: [1,3,12,0,0]
```
这个算法的时间复杂度是 O(n)，因为每个元素最多只会被遍历和交换一次。空间复杂度是 O(1)，因为我们在原地对数组进行操作，不需要额外的存储空间。

