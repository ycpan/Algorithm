# 组合总和
## 问题
给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。

对于给定的输入，保证和为 target 的不同组合数少于 150 个。



示例 1：
```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```
示例 2：
```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```
示例 3：
```
输入: candidates = [2], target = 1
输出: []
```
## 解答
要解决这个问题，我们可以使用回溯算法。回溯算法是一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会丢弃该解，即回溯并且尝试另一个候选解。这种策略可以避免在搜索空间中重复搜索，从而节省时间。
以下是解决这个问题的 Python 代码示例：
```python
def combinationSum(candidates, target):
    def backtrack(remaining, comb, start):
        if remaining == 0:
            result.append(list(comb))
            return
        elif remaining < 0:
            # 超过了目标，所以不需要继续递归
            return
        for i in range(start, len(candidates)):
            # 选择当前数字，加入到组合中
            comb.append(candidates[i])
            # 给剩余的目标减去当前数字，并递归
            backtrack(remaining - candidates[i], comb, i)
            # 撤销选择，以便尝试其他数字
            comb.pop()
    result = []
    backtrack(target, [], 0)
    return result
# 示例 1
print(combinationSum([2,3,6,7], 7))  # 输出：[[2,2,3],[7]]
# 示例 2
print(combinationSum([2,3,5], 8))  # 输出：[[2,2,2,2],[2,3,3],[3,5]]
# 示例 3
print(combinationSum([2], 1))  # 输出：[]
```
这段代码定义了一个内部函数 `backtrack`，它负责递归地搜索所有可能的组合。它接受当前剩余的目标值 `remaining`，当前的组合 `comb`，以及搜索的起始位置 `start`。在每一步，算法会尝试将 `candidates` 中从 `start` 开始的每一个数字加入到 `comb` 中，然后递归地调用 `backtrack`。如果加入一个数字后 `remaining` 变成 0，表示找到了一个有效的组合，我们将其添加到结果列表 `result` 中。如果 `remaining` 小于 0，表示当前组合不可能达到目标，因此返回。在每次递归调用之后，我们撤销选择（即从 `comb` 中移除最后一个数字），以便尝试其他可能的数字。递归的起始位置是 `i` 而不是 `i+1`，因为题目允许同一个数字被无限制重复选取。

