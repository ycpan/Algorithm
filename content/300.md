# 最长递增子序列
## 问题
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的
子序列
。


示例 1：
```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```
示例 2：
```
输入：nums = [0,1,0,3,2,3]
输出：4
```
示例 3：
```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```
## 解答
这个问题可以通过动态规划来解决。我们可以定义一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长严格递增子序列的长度。对于每个元素 `nums[i]`，我们需要遍历在它之前的所有元素 `nums[j]`（其中 `j < i`），如果 `nums[i] > nums[j]`，那么 `dp[i]` 可以更新为 `max(dp[i], dp[j] + 1)`。
算法步骤如下：
1. 初始化数组 `dp`，其中每个元素都为 1，因为每个单独的元素都是一个长度为 1 的递增子序列。
2. 遍历数组 `nums`，对于每个元素 `nums[i]`，遍历在它之前的所有元素 `nums[j]`。
3. 如果 `nums[i] > nums[j]`，则更新 `dp[i]` 为 `max(dp[i], dp[j] + 1)`。
4. 在遍历过程中，记录 `dp` 数组中的最大值，这个最大值就是最长严格递增子序列的长度。
现在，我们可以用 Python 代码来实现这个算法。
```python
def lengthOfLIS(nums):
    if not nums:
        return 0
    # 初始化dp数组
    dp = [1] * len(nums)
    # 遍历数组nums
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    # 返回dp数组中的最大值
    return max(dp)
# 测试示例
print(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]))  # 输出应该是 4
print(lengthOfLIS([0, 1, 0, 3, 2, 3]))           # 输出应该是 4
print(lengthOfLIS([7, 7, 7, 7, 7, 7, 7]))        # 输出应该是 1
4
4
1
```
正如预期的那样，当输入为 `nums = [10, 9, 2, 5, 3, 7, 101, 18]` 时，输出是 4，因为最长递增子序列是 `[2, 3, 7, 101]`；当输入为 `nums = [0, 1, 0, 3, 2, 3]` 时，输出是 4；当输入为 `nums = [7, 7, 7, 7, 7, 7, 7]` 时，输出是 1，因为每个单独的元素都是一个长度为 1 的递增子序列。
这个算法有效地解决了给定的问题，通过动态规划找到了最长严格递增子序列的长度。

